# switch-extension syntax
# refer xfrp syntax(https://github.com/psg-titech/xfrp/blob/master/syntax.txt)

# Legends
#   foo      : nonterminal symbol
#   'foo'    : terminal symbol
#   [ ... ]  : optional
#   { ... }* : repetition (0 or more times)
#   { ... }+ : repetition (1 or more times)
#
# Grammar Definitions
#   foo ::= ...  : definition in EBNF
#   foo = ...    : definition in regular expression


### whole module ###
progModule ::=
   'switchmodule' identifier
  ['in'  inNode {',' inNode}*]
  ['out' idAndType {',' idAndType}*]
  ['use' identifier {',' identifier}*]
  'init' identifier '(' [{literal}*]')'
  { definition }+
inNode ::= identifier ['(' literal ')'] ':' typeSpec


### toplevel definitions ###
definition ::=
    'data' idAndTypeOpt '=' expression
  | 'type' identifier '=' consDefinition {'|' consDefinition}*
  | 'func' identifier fargs [':' typeSpec] '=' expression
  | stateDefinition

consDefinition ::= identifier ['(' typeSpec {',' typeSpec}*')']

stateDefinition ::=
  'state' identifier sprms '{'
  {nodeDefinition}+
  'switch:' expression
  '}'

nodeDefinition ::= 'node' ['init' '[' expression ']'] idAndTypeOpt '=' expression
sprms ::= '(' [idAndType {',' idAndType}* ] ')'
fargs ::= '(' [idAndTypeOpt {',' idAndTypeOpt}* ] ')'

### expression ###
# note : pattern match syntax with indent is not supported 
expression ::=
    uniOp expression
  | expression binOp expression
  | '(' expression {',' expression}* ')'                 # tuple or paren
  | literal                                              # constant
  | 'Retain'                                             # Retain
  | identifier                                           # node or data
  | identifier '@' annotation                            # node with annotation
  | identifier args                                      # funcall or AGT constructor
  | 'if' expression 'then' expression 'else' expression  # if-expr
  | '{' { binder }+  expression '}'                      # let-expr
  | expression 'of' matchBranch {',' matchBranch}*       # pattern match
args ::= '(' [expression {',' expression}*] ')'
binder ::= idAndTypeOpt '=' expression
matchBranch :: = pattern '->' expression

uniOp ::= '+' | '-' | '!' | '~'

binOp ::=
    '*' | '/' | '%'
  | '+' | '-'
  | '<<' | '>>'
  | '<' | '<=' | '>=' | '>'
  | '==' | '!='
  | '&'
  | '^'
  | '|'
  | '&&'
  | '||'

annotation ::= 'last'

pattern ::=
    '_'
  | identifier
  | literal
  | '(' pattern {',' pattern}* ')' # tuple
  | identifier '(' pattern {',' pattern}* ')' # ADT

### primitives ###
identifier = [A-Za-z][A-Za-z0-9_]*

idAndType ::= identifier ':' typeSpec
idAndTypeOpt ::= identifier [':' typeSpec]

literal ::=
    'True'
  | 'False'
  | number
# todo :
#  | '()'
#  | charLiteral       

number ::=
    decimalNumber
# todo :
#  | octalNumber
#  | hexadecimalNumber
#  | floatNumber

typeSpec ::=
    'Bool' | 'Int' | 'Float' | identifier
  | '(' typeSpec {',' typeSpec}* ')'
# todo :
'Unit' | 'Char'

