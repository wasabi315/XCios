# switch-extension syntax
# refer xfrp syntax(https://github.com/psg-titech/xfrp/blob/master/syntax.txt)

# Legends
#   foo      : nonterminal symbol
#   'foo'    : terminal symbol
#   [ ... ]  : optional
#   { ... }* : repetition (0 or more times)
#   { ... }+ : repetition (1 or more times)
#
# Grammar Definitions
#   foo ::= ...  : definition in EBNF
#   foo = ...    : definition in regular expression


### whole module ###
program ::= xfrpModule | xfrpSModule

xfrpModule ::=
  'module' uidentifier
  ['in'  nodeDecl {',' nodeDecl}*]
  ['out' nodeDecl {',' nodeDecl}*]
  ['use' uidentifier {',' uidentifier}*]
  { definitionM }+

xfrpSModule ::=
   'switchmodule' uidentifier
  ['in'  nodeDecl {',' nodeDecl}*]
  ['out' nodeDecl {',' nodeDecl}*]
  ['use' uidentifier {',' uidentifier}*]
  'init' uidentifier [literal]
  { definitionSM }+

nodeDecl ::= identifier ['(' literal ')'] : typeSpec

### toplevel definitions ###
definitionM ::=
  | constDefinition
  | typeDefinition
  | funDefinition
  | nodeDefinition

definitionSM ::=
  | constDefinition
  | typeDefinition
  | funDefinition
  | stateDefinition

constDefinition ::= 'const' idAndTypeOpt '=' expression

typeDefinition ::= 'type' uidentifier '='
                   variantDefinition {'|' variantDefinition}*
variantDefinition ::= identifier ['of' typeSpec]

funDefinition ::=
  'fun' identifier '(' [idAndTypeOpt {',' idAndTypeOpt}* ] ')' [':' typeSpec]
  '=' expression

nodeDefinition ::= 'node' ['init' '[' literal ']'] idAndTypeOpt '=' expression

stateDefinition ::=
  'state' identifier ['(' idAndType {',' idAndType}*  ')'] '{'
  {nodeDefinition}+
  'switch:' expression
  '}'

### expression ###
expression ::=
    uniOp expression
  | expression binOp expression
  | '(' expression {',' expression}* ')'                 # tuple or paren
  | uidentifier [expression]                             # variant
  | prim_literal                                         # constant
  | 'Retain'                                             # Retain
  | identifier                                           # identifier
  | identifier '@' annotation                            # node with annotation
  | identifier '(' [expression {',' expression}*] ')'    # funcall
  | 'if' expression 'then' expression 'else' expression  # if-expr
  | 'let' binder {';' binder}* 'in' expression           # let-expr
  | 'case' expression 'of' {branch}+                     # pattern match
binder ::= idAndTypeOpt '=' expression
branch :: = pattern '->' expression ';'

uniOp ::= '+' | '-' | '!' | '~'

binOp ::=
    '*' | '/' | '+' | '-'
  | '*.' | '/.' | '+.' | '-.'
  | '%'| '<<' | '>>'
  | '<' | '<=' | '>=' | '>'
  | '<.' | '<=.' | '>=.' | '>.'
  | '==' | '!='
  | '&'
  | '^'
  | '|'
  | '&&'
  | '||'

annotation ::= 'last'

pattern ::=
    '_'
  | identifier
  | prim_literal
  | '(' pattern {',' pattern}* ')' # tuple
  | uidentifier pattern            # ADT

### primitives ###
identifier = [a-z][A-Za-z0-9_]*
uidentifier = [A-Z][A-Za-z0-9_]*

idAndType ::= identifier ':' typeSpec
idAndTypeOpt ::= identifier [':' typeSpec]

literal ::=
    primLiteral
  | '(' [literal {',' literal}*] ')'
  | uidentifier [literal]

primLiteral ::=
    'True'
  | 'False'
  | '()'
  | number
# | charLiteral

number ::=
     decimalNumber
   | floatNumber
#  | octalNumber
#  | hexadecimalNumber

typeSpec ::=
    'Bool' | 'Int' | 'Float' | 'Unit'
  | identifier
  | '(' typeSpec {',' typeSpec}* ')'
# | 'Char'
